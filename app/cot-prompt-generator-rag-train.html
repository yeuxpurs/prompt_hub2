<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RAG Prompt Generator</title>
  <style>
    /* --- Basic Styles --- */
    :root {
      --bg: #f8f9fa;
      --card: #ffffff;
      --ink: #212529;
      --muted: #6c757d;
      --brand: #0d6efd;
      --ok: #198754;
      --warn: #ffc107;
      --danger: #dc3545;
      --radius: 12px;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: "Pretendard", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
    }
    .wrap { max-width: 1200px; margin: 32px auto; padding: 0 24px; }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 24px;
    }
    .title { font-weight: 700; font-size: 24px; }
    .subtitle { color: var(--muted); font-size: 14px; }
    .controls { display: flex; gap: 12px; align-items: center; }
    .controls label { font-size: 14px; font-weight: 500; color: var(--muted); }
    .controls select {
      width: auto;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #ced4da;
      background: #fff;
      font-size: 14px;
      color: var(--ink);
    }
    .grid { display: grid; grid-template-columns: 1fr 1.2fr; gap: 24px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }
    .card {
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 24px;
      border: 1px solid #dee2e6;
    }
    .card h3 { margin: 0 0 16px; font-size: 18px; font-weight: 600; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px; }
    .row:last-child { margin-bottom: 0; }
    .row-stack { display: flex; flex-direction: column; gap: 10px; }
    label { display: block; font-size: 13px; color: var(--muted); margin-bottom: 8px; font-weight: 500; }
    input[type="text"], input[type="date"], textarea, select {
      width: 100%;
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid #ced4da;
      background: #fff;
      font-size: 14px;
      color: var(--ink);
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--brand);
      box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.2);
    }
    textarea { resize: vertical; min-height: 90px; }
    .btns { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 8px; }
    .btn {
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      background: var(--brand);
      color: #fff;
      font-size: 14px;
      transition: background-color 0.2s, transform 0.1s;
    }
    .btn:hover { background: #0b5ed7; }
    .btn:active { transform: translateY(1px); }
    .btn.secondary {
      background: #e9ecef;
      color: #212529;
    }
    .btn.secondary:hover { background: #d3d9df; }
    .out {
      white-space: pre-wrap;
      background: #212529;
      color: #f8f9fa;
      padding: 16px;
      border-radius: 8px;
      font-family: Consolas, monospace;
      font-size: 13px;
      line-height: 1.7;
      overflow: auto;
      min-height: 240px;
      border: 1px solid #495057;
    }
    .pill {
      font-size: 12px;
      font-weight: 500;
      color: #495057;
      background: #e9ecef;
      border-radius: 999px;
      padding: 6px 10px;
      display: inline-block;
    }
    .hr { height: 1px; background: #e9ecef; margin: 24px 0; }
    .kbd { font-family: monospace; font-size: 12px; background: #e9ecef; color: #212529;
           padding: 3px 6px; border-radius: 4px; border: 1px solid #dee2e6;}
    #toast {
      position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
      background-color: #333; color: #fff;
      padding: 14px 24px;
      border-radius: 50px;
      font-size: 14px;
      z-index: 1000;
      opacity: 0; visibility: hidden;
      transition: opacity 0.5s, visibility 0.5s, bottom 0.5s;
    }
    #toast.show {
      opacity: 1;
      visibility: visible;
      bottom: 50px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div id="app_title" class="title">ğŸš— ìë™ì°¨ ê³µí•™ ë¬¸ì œ í•´ê²° í”„ë¡¬í”„íŠ¸ ìƒì„±ê¸°</div>
        <div id="app_subtitle" class="subtitle">
          ê¸°ìˆ  ë¬¸ì„œ ê²€ìƒ‰ ë° ë³´ê³ ì„œ ìƒì„±ì„ ìœ„í•œ í”„ë¡¬í”„íŠ¸ë¥¼ ì²´ê³„ì ìœ¼ë¡œ êµ¬ì„±í•©ë‹ˆë‹¤.
        </div>
      </div>
      <div class="controls">
        <label for="language">Language:</label>
        <select id="language">
          <option value="ko">í•œêµ­ì–´ (KO)</option>
          <option value="en">English (EN)</option>
        </select>
        <label for="domain">Domain:</label>
        <select id="domain">
          <option value="auto">Automotive</option>
          <option value="finance">Finance</option>
          <option value="medical">Medical</option>
          <option value="general">General</option>
        </select>
        <label for="model">Model:</label>
        <select id="model">
          <option value="GPT-4">GPT-4</option>
          <option value="GPT-3.5">GPT-3.5</option>
          <option value="LLaMA2 13B">LLaMA2 13B</option>
          <option value="LLaMA2 7B">LLaMA2 7B</option>
          <option value="Other">Custom/Other</option>
        </select>
      </div>
    </header>

    <div class="grid">
      <!-- Input Panel -->
      <section class="card">
        <h3>1. ë¶„ì„ ëª©í‘œ ì„¤ì •</h3>
        <div class="row">
          <div>
            <label id="label_role">ë‚˜ì˜ ì—­í•  (Persona)</label>
            <input id="role" type="text" placeholder="ì˜ˆ: íŒŒì›ŒíŠ¸ë ˆì¸ í’ˆì§ˆ ì—”ì§€ë‹ˆì–´" />
          </div>
          <div>
            <label id="label_goal">í•µì‹¬ ëª©í‘œ (Goal)</label>
            <input id="goal" type="text" placeholder="ì˜ˆ: 'í”¼ë‹‰ìŠ¤' í”„ë¡œì íŠ¸ ì—”ì§„ ê³¼ì—´ ì›ì¸ ë¶„ì„ ë³´ê³ ì„œ ì´ˆì•ˆ" />
          </div>
        </div>
        <div class="row">
          <div>
            <label id="label_context">ì£¼ìš” ì •ë³´ (Context)</label>
            <textarea id="context" placeholder="ì˜ˆ: í”¼ë‹‰ìŠ¤ í”„ë¡œì íŠ¸, 2.5L í„°ë³´ ì—”ì§„, ë‚´êµ¬ í…ŒìŠ¤íŠ¸ ì¤‘ ê³¼ì—´ í˜„ìƒ ë°œìƒ"></textarea>
          </div>
          <div>
            <label id="label_constraints">ê²°ê³¼ë¬¼ ì œì•½ ì¡°ê±´ (Constraints)</label>
            <textarea id="constraints" placeholder="ì˜ˆ: Markdown í˜•ì‹, í‘œì™€ bullet ì‚¬ìš©, ì›ì¸-ê²°ê³¼ ê´€ê³„ë¡œ ì„œìˆ "></textarea>
          </div>
        </div>
        <div class="hr"></div>
        <h3>2. ê²€ìƒ‰ ì¡°ê±´</h3>
        <div class="row">
          <div>
            <label id="label_entities">í•µì‹¬ ì—”í‹°í‹°/í‚¤ì›Œë“œ</label>
            <input id="entities" type="text" placeholder="ì˜ˆ: ì—”ì§„ ê³¼ì—´, ëƒ‰ê°ìˆ˜, ë¼ë””ì—ì´í„°, ì„œëª¨ìŠ¤íƒ¯" />
          </div>
          <div class="row">
            <div>
              <label id="label_time_from">ê¸°ê°„ (ì‹œì‘)</label>
              <input id="time_from" type="date" />
            </div>
            <div>
              <label id="label_time_to">ê¸°ê°„ (ì¢…ë£Œ)</label>
              <input id="time_to" type="date" />
            </div>
          </div>
        </div>
        <div class="row">
          <div>
            <label id="label_sources">ê²€ìƒ‰ ëŒ€ìƒ ë°ì´í„°ì†ŒìŠ¤</label>
            <div class="row-stack">
              <div><input type="checkbox" id="src_tech_docs" /> <label for="src_tech_docs">ê¸°ìˆ  ë¬¸ì„œ ì„œë²„</label></div>
              <div><input type="checkbox" id="src_test_reports" /> <label for="src_test_reports">ì‹œí—˜ ê²°ê³¼ DB</label></div>
              <div><input type="checkbox" id="src_email" /> <label for="src_email">ì´ë©”ì¼ ì•„ì¹´ì´ë¸Œ</label></div>
            </div>
          </div>
          <div>
            <label id="label_search_mode">ê²€ìƒ‰ ë°©ì‹</label>
            <select id="search_mode">
              <option value="hybrid">Hybrid (í‚¤ì›Œë“œ + ì˜ë¯¸ ê¸°ë°˜)</option>
              <option value="keyword">í‚¤ì›Œë“œ ê¸°ë°˜</option>
              <option value="semantic">ì˜ë¯¸ ê¸°ë°˜ (Semantic)</option>
            </select>
          </div>
        </div>
        <div class="hr"></div>
        <h3>3. ìƒì„¸ ì§ˆì˜ ë° HyDE ìƒì„±</h3>
        <div class="row">
          <div>
            <label id="label_queries">ìƒì„±ëœ ê²€ìƒ‰ ì§ˆì˜ (í•„ìš”ì‹œ ìˆ˜ì •)</label>
            <textarea id="queries" placeholder="ì—”í‹°í‹°ì™€ ì»¨í…ìŠ¤íŠ¸ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìë™ ìƒì„±ë©ë‹ˆë‹¤."></textarea>
            <div class="btns">
              <button class="btn secondary" id="btn_gen_queries">ì§ˆì˜ ìë™ ìƒì„±</button>
            </div>
          </div>
          <div>
            <label id="label_hyde">ê°€ìƒ ë‹µë³€ (Hypothetical Answer)</label>
            <textarea id="hyde" placeholder="ìë™ ìƒì„±ëœ ê°€ìƒ ë‹µë³€ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤."></textarea>
            <div class="btns">
              <button class="btn secondary" id="btn_gen_hyde">ê°€ìƒ ë‹µë³€ ìƒì„±</button>
            </div>
          </div>
        </div>
      </section>

      <!-- Output Panel -->
      <section class="card">
        <h3 id="label_final_prompt">ìµœì¢… í”„ë¡¬í”„íŠ¸</h3>
        <div class="btns" style="margin-bottom: 16px;">
          <button class="btn" id="btn_build">ì¬ìƒì„±</button>
          <button class="btn secondary" id="btn_copy">ì „ì²´ ë³µì‚¬</button>
          <button class="btn secondary" id="btn_clear">ì´ˆê¸°í™”</button>
        </div>
        <div class="btns">
          <button class="btn secondary" id="btn_export_json">Export JSON</button>
          <button class="btn secondary" id="btn_export_csv">Export CSV</button>
          <button class="btn secondary" id="btn_export_instr">Export Instruct JSON</button>
        </div>
        <div class="pill">[SYSTEM PROMPT]</div>
        <div id="prompt_out" class="out" aria-label="prompt output"></div>
      </section>
    </div>
  </div>

  <div id="toast"></div>

  <script>
    // --- Configuration for domains and translations ---
    const domainConfigs = {
      auto: {
        icon: "ğŸš—",
        title: { ko: "ìë™ì°¨ ê³µí•™ ë¬¸ì œ í•´ê²°", en: "Automotive Problem Solving" },
        subtitle: {
          ko: "ê¸°ìˆ  ë¬¸ì„œ ê²€ìƒ‰ ë° ë³´ê³ ì„œ ìƒì„±ì„ ìœ„í•œ í”„ë¡¬í”„íŠ¸ë¥¼ ì²´ê³„ì ìœ¼ë¡œ êµ¬ì„±í•©ë‹ˆë‹¤.",
          en: "Structuring prompts for technical document search and report generation."
        },
        defaultRole: { ko: "ìë™ì°¨ ê³µí•™ ì „ë¬¸ê°€", en: "automotive engineering expert" },
        knowledgeSource: { ko: "ê¸°ìˆ  ë¬¸ì„œ", en: "technical documents" },  // used in system instruction line about evidence
        sourceLabels: {
          ko: { tech_docs: "ê¸°ìˆ  ë¬¸ì„œ ì„œë²„", test_reports: "ì‹œí—˜ ê²°ê³¼ DB", email: "ì´ë©”ì¼ ì•„ì¹´ì´ë¸Œ" },
          en: { tech_docs: "Technical Docs Server", test_reports: "Test Results DB", email: "Email Archive" }
        },
        defaultSources: { tech_docs: true, test_reports: true, email: false },  // default checkbox states
        // Domain-specific synonyms for query expansion (keys and values cover Korean and English where appropriate)
        synonyms: {
          "ì—”ì§„": ["ì—”ì§„ê³¼ì—´", "overheating"],  // sample entry linking engine overheating
          "ì—”ì§„ê³¼ì—´": ["ì—”ì§„ ê³¼ì—´", "engine overheating"],
          "ëƒ‰ê°ìˆ˜": ["ë¶€ë™ì•¡", "coolant"],
          "ë¼ë””ì—ì´í„°": ["radiator", "ë°©ì—´ê¸°"],
          "ì„œëª¨ìŠ¤íƒ¯": ["thermostat", "ì˜¨ë„ì¡°ì ˆì¥ì¹˜"],
          "í…ŒìŠ¤íŠ¸": ["ì‹œí—˜", "test"],
          "í”„ë¡œì íŠ¸": ["project"]
        },
        example: { // Example preset scenario for automotive domain
          role: "íŒŒì›ŒíŠ¸ë ˆì¸ í’ˆì§ˆ ì—”ì§€ë‹ˆì–´",
          goal: "'í”¼ë‹‰ìŠ¤' í”„ë¡œì íŠ¸ ì—”ì§„ ê³¼ì—´ ì›ì¸ ë¶„ì„ ë³´ê³ ì„œ ì´ˆì•ˆ",
          context: "í”¼ë‹‰ìŠ¤ í”„ë¡œì íŠ¸ ì°¨ëŸ‰ì˜ 2.5L ê°€ì†”ë¦° í„°ë³´ ì—”ì§„ì´ ë‚´êµ¬ ì‹œí—˜ ì¤‘ íŠ¹ì • ê³ ë¶€í•˜ ì¡°ê±´ì—ì„œ ê³¼ì—´ë˜ëŠ” í˜„ìƒì´ ë°œìƒí•¨",
          constraints: "Markdown í˜•ì‹, bullet í¬ì¸íŠ¸ë¡œ ì›ì¸ ë° í•´ê²° ë°©ì•ˆ ì •ë¦¬",
          entities: "ì—”ì§„ ê³¼ì—´, ëƒ‰ê°ìˆ˜, ë¼ë””ì—ì´í„°, ì„œëª¨ìŠ¤íƒ¯, ì›Œí„°íŒí”„",
          time_from: "", time_to: "",  // no specific date range
          search_mode: "hybrid",
          sources: { tech_docs: true, test_reports: true, email: false }
        }
      },
      finance: {
        icon: "ğŸ’¼",
        title: { ko: "ê¸ˆìœµ ë¶„ì„", en: "Financial Analysis" },
        subtitle: {
          ko: "ë‚´ë¶€ ì¬ë¬´ ë°ì´í„° ê²€ìƒ‰ ë° ìš”ì•½ ë³´ê³ ì„œ ì‘ì„±ì„ ìœ„í•œ í”„ë¡¬í”„íŠ¸ ìƒì„±ê¸°.",
          en: "Structuring prompts for financial data retrieval and summary report generation."
        },
        defaultRole: { ko: "ì¬ë¬´ ë¶„ì„ê°€", en: "financial analyst" },
        knowledgeSource: { ko: "ì¬ë¬´ ë¬¸ì„œ", en: "financial documents" },
        sourceLabels: {
          ko: { tech_docs: "ì¬ë¬´ ë³´ê³ ì„œ DB", test_reports: "ì‹œì¥ ë°ì´í„°ë² ì´ìŠ¤", email: "ì´ë©”ì¼ ì•„ì¹´ì´ë¸Œ" },
          en: { tech_docs: "Financial Reports DB", test_reports: "Market Data DB", email: "Email Archive" }
        },
        defaultSources: { tech_docs: true, test_reports: true, email: false },
        synonyms: {
          "ì‹œì¥": ["ë§ˆì¼“", "market"],
          "ë³€ë™ì„±": ["volatility"],
          "ê¸ˆë¦¬": ["ì´ììœ¨", "interest rate"],
          "ì¸í”Œë ˆì´ì…˜": ["ë¬¼ê°€ìƒìŠ¹", "inflation"],
          "ì£¼ê°€": ["stock price", "share price"]
        },
        example: {
          role: "ì¬ë¬´ ë¶„ì„ê°€",
          goal: "2025ë…„ 3ë¶„ê¸° ì‹œì¥ ë³€ë™ì„± ë¶„ì„ ë³´ê³ ì„œ ì´ˆì•ˆ",
          context: "2025ë…„ 3ë¶„ê¸° ì£¼ì‹ ì‹œì¥ì—ì„œ ê¸ˆë¦¬ ìƒìŠ¹ê³¼ ì§€ì •í•™ì  ê¸´ì¥ìœ¼ë¡œ ì¸í•´ í° í­ì˜ ë³€ë™ì„±ì´ ê´€ì°°ë¨",
          constraints: "Markdown í‘œ í¬í•¨, ì›ì¸ê³¼ ì˜í–¥ìœ¼ë¡œ êµ¬ë¶„í•˜ì—¬ ì‘ì„±",
          entities: "ì‹œì¥ ë³€ë™ì„±, ê¸ˆë¦¬ ìƒìŠ¹, ì§€ì •í•™ì  ë¦¬ìŠ¤í¬, ì¸í”Œë ˆì´ì…˜, ì£¼ê°€ ì§€ìˆ˜",
          time_from: "2025-07-01", time_to: "2025-09-30",
          search_mode: "hybrid",
          sources: { tech_docs: true, test_reports: true, email: false }
        }
      },
      medical: {
        icon: "ğŸ’Š",
        title: { ko: "ì˜ë£Œ ì—°êµ¬", en: "Medical Research" },
        subtitle: {
          ko: "ì˜ë£Œ ë¬¸í—Œ ê²€ìƒ‰ ë° ê²°ê³¼ ë³´ê³ ì„œ ìƒì„±ì„ ìœ„í•œ í”„ë¡¬í”„íŠ¸ ìƒì„±ê¸°.",
          en: "Structuring prompts for medical literature search and findings report generation."
        },
        defaultRole: { ko: "ì„ìƒ ì—°êµ¬ì›", en: "clinical researcher" },
        knowledgeSource: { ko: "ì˜ë£Œ ìë£Œ", en: "medical literature" },
        sourceLabels: {
          ko: { tech_docs: "ì˜í•™ ì €ë„ DB", test_reports: "ì„ìƒì‹œí—˜ ë°ì´í„°", email: "ì¼€ì´ìŠ¤ ê¸°ë¡ ë³´ê´€ì†Œ" },
          en: { tech_docs: "Medical Journals DB", test_reports: "Clinical Trials DB", email: "Case Archive" }
        },
        defaultSources: { tech_docs: true, test_reports: true, email: false },
        synonyms: {
          "ì„ìƒì‹œí—˜": ["clinical trial"],
          "ë¶€ì‘ìš©": ["ì´ìƒ ë°˜ì‘", "side effect", "adverse event"],
          "ì•½ë¬¼": ["drug", "medication"],
          "í™˜ì": ["patient"],
          "ë°ì´í„°": ["data"]
        },
        example: {
          role: "ì„ìƒ ì—°êµ¬ì›",
          goal: "ì‹ ì•½ X ì„ìƒì‹œí—˜ ë¶€ì‘ìš© ì›ì¸ ë¶„ì„ ë³´ê³ ì„œ ì´ˆì•ˆ",
          context: "ì‹ ì•½ Xì— ëŒ€í•œ 3ìƒ ì„ìƒì‹œí—˜ ì¤‘ ë‹¤ìˆ˜ì˜ í™˜ìì—ì„œ ì‹¬ê°í•˜ì§€ëŠ” ì•Šì§€ë§Œ ê³µí†µëœ ë¶€ì‘ìš©(ë‘í†µ, ì–´ì§€ëŸ¬ì›€)ì´ ë³´ê³ ë¨",
          constraints: "ê²°ê³¼ëŠ” í‘œë¡œ ì •ë¦¬, ì›ì¸ ê°€ëŠ¥ì„±ë³„ë¡œ ì„¹ì…˜ êµ¬ë¶„",
          entities: "ì„ìƒì‹œí—˜, ë¶€ì‘ìš©, ì•½ë¬¼ ëŒ€ì‚¬, í™˜ì ë°ì´í„°, í†µê³„ ë¶„ì„",
          time_from: "", time_to: "",
          search_mode: "hybrid",
          sources: { tech_docs: true, test_reports: true, email: false }
        }
      },
      general: {
        icon: "ğŸ“",
        title: { ko: "ë²”ìš© RAG", en: "General RAG" },
        subtitle: {
          ko: "ë²”ìš© ì •ë³´ ê²€ìƒ‰ ë° ìƒì„±í˜• ì‘ë‹µì„ ìœ„í•œ í”„ë¡¬í”„íŠ¸ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.",
          en: "Structuring prompts for general retrieval-augmented generation tasks."
        },
        defaultRole: { ko: "ì§€ì‹ ì „ë¬¸ê°€", en: "domain expert" },
        knowledgeSource: { ko: "ë¬¸ì„œ", en: "documents" },
        sourceLabels: {
          ko: { tech_docs: "ë¬¸ì„œ ë°ì´í„°ë² ì´ìŠ¤", test_reports: "ê¸°ë¡ ì €ì¥ì†Œ", email: "ì´ë©”ì¼ ì•„ì¹´ì´ë¸Œ" },
          en: { tech_docs: "Document Database", test_reports: "Records Repository", email: "Email Archive" }
        },
        defaultSources: { tech_docs: true, test_reports: true, email: false },
        synonyms: {
          // General synonyms can be minimal or none; users can add as needed
        },
        example: {
          role: "",
          goal: "",
          context: "",
          constraints: "",
          entities: "",
          time_from: "", time_to: "",
          search_mode: "hybrid",
          sources: { tech_docs: true, test_reports: true, email: false }
        }
      }
    };

    // Static translations for UI labels and prompt section titles in each language
    const translations = {
      ko: {
        labels: {
          role: "ë‚˜ì˜ ì—­í•  (Persona)",
          goal: "í•µì‹¬ ëª©í‘œ (Goal)",
          context: "ì£¼ìš” ì •ë³´ (Context)",
          constraints: "ê²°ê³¼ë¬¼ ì œì•½ ì¡°ê±´ (Constraints)",
          entities: "í•µì‹¬ ì—”í‹°í‹°/í‚¤ì›Œë“œ",
          time_from: "ê¸°ê°„ (ì‹œì‘)",
          time_to: "ê¸°ê°„ (ì¢…ë£Œ)",
          sources: "ê²€ìƒ‰ ëŒ€ìƒ ë°ì´í„°ì†ŒìŠ¤",
          search_mode: "ê²€ìƒ‰ ë°©ì‹",
          queries: "ìƒì„±ëœ ê²€ìƒ‰ ì§ˆì˜ (í•„ìš”ì‹œ ìˆ˜ì •)",
          hyde: "ê°€ìƒ ë‹µë³€ (Hypothetical Answer)",
          final_prompt: "ìµœì¢… í”„ë¡¬í”„íŠ¸"
        },
        // Search mode option text (to set <option> display)
        modes: {
          hybrid: "Hybrid (í‚¤ì›Œë“œ + ì˜ë¯¸ ê¸°ë°˜)",
          keyword: "í‚¤ì›Œë“œ ê¸°ë°˜",
          semantic: "ì˜ë¯¸ ê¸°ë°˜ (Semantic)"
        },
        // Prompt section titles and default "not provided" placeholders
        promptSections: {
          goal: "## 1. ìµœì¢… ëª©í‘œ (GOAL)",
          context: "## 2. ë°°ê²½ ì •ë³´ (CONTEXT)",
          entities: "## 3. í•µì‹¬ í‚¤ì›Œë“œ",
          retrievalPlan: "## 4. ê²€ìƒ‰ ê³„íš (RETRIEVAL PLAN)",
          outputFormat: "## 5. ê²°ê³¼ë¬¼ í˜•ì‹ (OUTPUT FORMAT)",
          noGoal: "(ëª©í‘œê°€ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤)",
          noContext: "(ë°°ê²½ ì •ë³´ê°€ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤)",
          noEntities: "(í‚¤ì›Œë“œê°€ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤)",
          noQueries: "ìƒì„±ëœ ì§ˆì˜ê°€ ì—†ìŠµë‹ˆë‹¤"
        },
        outputGuidelines: [
          "- ëª¨ë“  ì£¼ì¥ì˜ ê·¼ê±°ê°€ ë˜ëŠ” ë¬¸ì„œ ì •ë³´ë¥¼ ë°˜ë“œì‹œ ì¸ìš©([Source 1], [Source 2] í˜•ì‹)í•´ì•¼ í•©ë‹ˆë‹¤.",
          "- ì¶©ë¶„í•œ ê·¼ê±°ë¥¼ ì°¾ì§€ ëª»í–ˆë‹¤ë©´, 'ê´€ë ¨ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ'ì´ë¼ê³  ëª…í™•íˆ ë°íˆì„¸ìš”.",
          "- Markdownì„ ì‚¬ìš©í•˜ì—¬ ê°€ë…ì„±ì„ ë†’ê²Œ ì‘ì„±í•˜ì„¸ìš”."
        ]
      },
      en: {
        labels: {
          role: "Your Role (Persona)",
          goal: "Main Goal",
          context: "Background Info (Context)",
          constraints: "Output Constraints",
          entities: "Key Entities/Keywords",
          time_from: "Date Range (Start)",
          time_to: "Date Range (End)",
          sources: "Data Sources",
          search_mode: "Search Mode",
          queries: "Generated Search Queries (edit if needed)",
          hyde: "Hypothetical Answer (HyDE)",
          final_prompt: "Final Prompt"
        },
        modes: {
          hybrid: "Hybrid (keyword + semantic)",
          keyword: "Keyword-based",
          semantic: "Semantic-based"
        },
        promptSections: {
          goal: "## 1. Final Goal (GOAL)",
          context: "## 2. Background Info (CONTEXT)",
          entities: "## 3. Key Entities",
          retrievalPlan: "## 4. Retrieval Plan",
          outputFormat: "## 5. Output Format",
          noGoal: "(No goal provided)",
          noContext: "(No background info provided)",
          noEntities: "(No keywords provided)",
          noQueries: "No queries generated"
        },
        outputGuidelines: [
          "- Cite the source document for every claim (e.g., [Source 1], [Source 2]).",
          "- If sufficient evidence is not found, state 'No relevant information found.' clearly.",
          "- Use Markdown formatting (tables, lists) for readability."
        ]
      }
    };

    // --- State Variables ---
    let currentLanguage = "ko";
    let currentDomain = "auto";
    let currentModel = "GPT-4";
    let queriesModified = false;
    let hydeModified = false;

    // --- Utility Functions ---
    /** Removes duplicates and falsy values from an array */
    const uniq = arr => [...new Set(arr.filter(Boolean))];
    /** Tokenizes text into keywords (splits on whitespace/punctuation, filters stopwords and short tokens) */
    const tokenize = text => {
      const STOPWORDS = new Set([
        "ê·¸ë¦¬ê³ ","ë˜í•œ","ë°","ê´€ë ¨","ëŒ€í•´",
        "the","and","in","on","of","for","to"
      ]);
      return text
        .toLowerCase()
        .split(/[\s,./;()\[\]{}<>~]+/)
        .map(t => t.trim())
        .filter(t => t && t.length > 1 && !STOPWORDS.has(t));
    };
    /** Displays a temporary toast message */
    const showToast = (message, duration = 2000) => {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => {
        toast.classList.remove('show');
      }, duration);
    };

    // --- Core Logic Functions ---

    /** Applies the selected language and domain to UI text (labels, placeholders, titles, etc.) */
    function updateUI() {
      const lang = currentLanguage;
      const domain = currentDomain;
      const config = domainConfigs[domain];
      const t = translations[lang];

      // Update page title and subtitle with domain-specific text and icon
      const titleEl = document.getElementById('app_title');
      const subtitleEl = document.getElementById('app_subtitle');
      titleEl.textContent = `${config.icon} ${config.title[lang]} í”„ë¡¬í”„íŠ¸ ìƒì„±ê¸°`;
      subtitleEl.textContent = config.subtitle[lang];

      // Update all input labels
      document.getElementById('label_role').innerText = t.labels.role;
      document.getElementById('label_goal').innerText = t.labels.goal;
      document.getElementById('label_context').innerText = t.labels.context;
      document.getElementById('label_constraints').innerText = t.labels.constraints;
      document.getElementById('label_entities').innerText = t.labels.entities;
      document.getElementById('label_time_from').innerText = t.labels.time_from;
      document.getElementById('label_time_to').innerText = t.labels.time_to;
      document.getElementById('label_sources').innerText = t.labels.sources;
      document.getElementById('label_search_mode').innerText = t.labels.search_mode;
      document.getElementById('label_queries').innerText = t.labels.queries;
      document.getElementById('label_hyde').innerText = t.labels.hyde;
      document.getElementById('label_final_prompt').innerText = t.labels.final_prompt;

      // Update source checkbox labels to domain-specific names in current language
      document.querySelector('label[for="src_tech_docs"]').innerText = config.sourceLabels[lang].tech_docs;
      document.querySelector('label[for="src_test_reports"]').innerText = config.sourceLabels[lang].test_reports;
      document.querySelector('label[for="src_email"]').innerText = config.sourceLabels[lang].email;

      // Update search mode select option texts for current language
      const modeSelect = document.getElementById('search_mode');
      modeSelect.options[0].text = t.modes.hybrid;
      modeSelect.options[1].text = t.modes.keyword;
      modeSelect.options[2].text = t.modes.semantic;

      // Update input placeholders for domain/language
      const roleInput = document.getElementById('role');
      const goalInput = document.getElementById('goal');
      const contextInput = document.getElementById('context');
      const constraintsInput = document.getElementById('constraints');
      const entitiesInput = document.getElementById('entities');
      // Set placeholder examples from domain's example config (if available)
      const example = config.example;
      roleInput.placeholder = example.role ? `ì˜ˆ: ${example.role}` : (lang === 'ko' ? "ì˜ˆ: ì „ë¬¸ê°€ ë˜ëŠ” ì§ì±…" : "e.g. Subject Matter Expert");
      goalInput.placeholder = example.goal ? `ì˜ˆ: ${example.goal}` : (lang === 'ko' ? "ì˜ˆ: í”„ë¡œì íŠ¸ ëª©í‘œ í˜¹ì€ ì§ˆë¬¸" : "e.g. project goal or question");
      contextInput.placeholder = example.context ? `ì˜ˆ: ${example.context}` : (lang === 'ko' ? "ì˜ˆ: ì¶”ê°€ ë°°ê²½ ì •ë³´ë‚˜ ìƒí™© ì„¤ëª…" : "e.g. background information or context");
      constraintsInput.placeholder = example.constraints ? `ì˜ˆ: ${example.constraints}` : (lang === 'ko' ? "ì˜ˆ: í˜•ì‹ì´ë‚˜ í†¤ì— ëŒ€í•œ ìš”êµ¬ì‚¬í•­" : "e.g. format or tone constraints");
      entitiesInput.placeholder = example.entities ? `ì˜ˆ: ${example.entities}` : (lang === 'ko' ? "ì˜ˆ: í‚¤ì›Œë“œ1, í‚¤ì›Œë“œ2" : "e.g. keyword1, keyword2");
    }

    /** Suggests search queries based on current inputs (role, goal, context, entities) using domain-specific synonyms. */
    function suggestQueries() {
      const config = domainConfigs[currentDomain];
      const textInputs = [
        document.getElementById('role').value,
        document.getElementById('goal').value,
        document.getElementById('context').value,
        document.getElementById('entities').value
      ].join(" ");
      // Tokenize and expand synonyms
      let tokens = uniq(tokenize(textInputs));
      const synMap = config.synonyms || {};
      const expanded = new Set(tokens);
      tokens.forEach(tok => {
        if (synMap[tok]) {
          synMap[tok].forEach(syn => expanded.add(syn));
        }
      });
      const keywords = Array.from(expanded);
      // Limit to top 10 tokens for query generation
      const base = keywords.slice(0, 10);

      const queries = [];
      if (base.length > 2) {
        // Create a few templated queries using top keywords (translated template remains in Korean/English as is)
        // Use currentLanguage to decide query language if needed (for simplicity, we keep queries in the language of input or domain context)
        if (currentLanguage === 'ko') {
          queries.push(`'${base[0]}' ì›ì¸ ë¶„ì„ ê´€ë ¨ ë¬¸ì„œ`);
          queries.push(`'${base[0]}' ê´€ë ¨ '${base[1]}' ì‹œí—˜ ê²°ê³¼ ë³´ê³ ì„œ`);
          queries.push(`'${base.slice(0, 3).join(' ')}' ë¬¸ì œ í•´ê²° ì‚¬ë¡€`);
        } else {
          // English query patterns
          queries.push(`"${base[0]}" root cause analysis documents`);
          queries.push(`"${base[0]}" and "${base[1]}" related test reports`);
          queries.push(`"${base.slice(0, 3).join(' ')}" issue resolution history`);
        }
      }
      // Always include the goal itself as a query (if not empty)
      const goalText = document.getElementById('goal').value.trim();
      if (goalText) queries.push(goalText);
      // Remove duplicates and empty, then join into textarea
      const uniqueQueries = uniq(queries).filter(Boolean);
      document.getElementById('queries').value = uniqueQueries.join('\n');
    }

    /** Generates a hypothetical answer (HyDE) based on current inputs, adapting length/style to selected model. */
    function generateHyde() {
      const lang = currentLanguage;
      const config = domainConfigs[currentDomain];
      const goal = document.getElementById('goal').value.trim();
      const context = document.getElementById('context').value.trim();
      const entities = document.getElementById('entities').value.trim();
      // Compile text for tokenization (goal + context + entities)
      const textInputs = [goal, context, entities].join(" ");
      let tokens = uniq(tokenize(textInputs));
      // Expand domain synonyms for tokens (to ensure we catch domain terms)
      const synMap = config.synonyms || {};
      const expanded = new Set(tokens);
      tokens.forEach(tok => {
        if (synMap[tok]) {
          synMap[tok].forEach(syn => expanded.add(syn));
        }
      });
      const keywords = Array.from(expanded);
      // Determine model capability (for simplicity, treat smaller models as needing simpler output)
      const model = currentModel;
      let useComplexAnswer = true;
      if (model.includes("7B") || model.includes("13B")) {
        useComplexAnswer = false;  // assume smaller model -> simpler/shorter HyDE
      }
      // Construct a hypothetical answer using up to 2-3 top keywords
      let hydeText = "";
      if (keywords.length === 0) {
        // If no info to go on, produce a generic "no info" or blank
        hydeText = (lang === 'ko')
          ? "ê´€ë ¨ ì •ë³´ë¥¼ ì°¾ê¸° ìœ„í•œ ì¶©ë¶„í•œ ë‹¨ì„œê°€ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
          : "Not enough information was provided to generate a hypothetical answer.";
      } else {
        const k1 = keywords[0] || ""; 
        const k2 = keywords[1] || "";
        const subject = goal || context || k1;  // use goal or context as subject if available
        if (lang === 'ko') {
          // Korean HyDE: craft 1-2 sentence summary
          if (useComplexAnswer) {
            hydeText = `${subject} ë¬¸ì œëŠ” ì£¼ë¡œ ${k1}${k2 ? " ë° " + k2 : ""} ìš”ì¸ìœ¼ë¡œ ì¸í•´ ë°œìƒí•œ ê²ƒìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤. ` +
                       `${k1 ? k1 + " ê´€ë ¨ ë°ì´í„°ì—ì„œ " : ""}${k2 ? k2 + " ì‚¬ë¡€ì—ì„œë„ " : ""}ìœ ì‚¬í•œ í˜„ìƒì´ ê´€ì°°ë˜ì—ˆìœ¼ë©°, ` +
                       `í•´ë‹¹ ì›ì¸ì„ ê°œì„ í•˜ë©´ ë¬¸ì œê°€ í•´ê²°ë  ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤.`;
          } else {
            // Simpler/shorter answer for less capable model
            hydeText = `${subject} í˜„ìƒì˜ ì£¼ìš” ì›ì¸ì€ ${k1}${k2 ? "ì™€ " + k2 + " ë•Œë¬¸" : " ë•Œë¬¸"}ìœ¼ë¡œ ì¶”ì •ë©ë‹ˆë‹¤.`;
          }
        } else {
          // English HyDE
          if (useComplexAnswer) {
            hydeText = `The ${subject} is likely caused by ${k1}${k2 ? " and " + k2 : ""}. ` +
                       `In particular, factors related to ${k1}${k2 ? " as well as " + k2 : ""} have been observed, ` +
                       `and addressing these could potentially resolve the issue.`;
          } else {
            hydeText = `The primary cause of the ${subject} appears to be ${k1}${k2 ? " and " + k2 : ""}.`;
          }
        }
      }
      document.getElementById('hyde').value = hydeText;
    }

    /** Builds the final prompt text from all inputs and templates. */
    function buildPrompt() {
      const lang = currentLanguage;
      const domain = currentDomain;
      const config = domainConfigs[domain];
      const tSec = translations[lang].promptSections;  // prompt section titles / placeholders
      // Gather user inputs (using placeholders if empty)
      const role = document.getElementById('role').value.trim() || config.defaultRole[lang];
      const goal = document.getElementById('goal').value.trim() || "";
      const context = document.getElementById('context').value.trim() || "";
      const constraints = document.getElementById('constraints').value.trim();
      const entities = document.getElementById('entities').value.trim() || "";
      const timeFrom = document.getElementById('time_from').value || (lang === 'ko' ? "ì „ì²´" : "All");
      const timeTo = document.getElementById('time_to').value || (lang === 'ko' ? "í˜„ì¬" : "Present");
      // Data sources list or 'all' if none unchecked
      const selectedSources = [];
      if (document.getElementById('src_tech_docs').checked) selectedSources.push(config.sourceLabels[lang].tech_docs);
      if (document.getElementById('src_test_reports').checked) selectedSources.push(config.sourceLabels[lang].test_reports);
      if (document.getElementById('src_email').checked) selectedSources.push(config.sourceLabels[lang].email);
      const sourcesText = (selectedSources.length > 0)
        ? selectedSources.join(', ')
        : (lang === 'ko' ? "ì „ì²´ ë°ì´í„°ì†ŒìŠ¤" : "All data sources");
      // Search mode text (use selected option's text to include proper language)
      const modeSelect = document.getElementById('search_mode');
      const searchModeText = modeSelect.selectedOptions[0].text;
      // Compile queries from textarea (one per line)
      const queryLines = document.getElementById('queries').value.trim().split(/\n+/).filter(Boolean);
      // Build each section of the prompt
      // 1. System Instructions (persona and rules)
      let systemInstructions = "";
      if (lang === 'ko') {
        systemInstructions += `ë„ˆëŠ” ìµœê³ ì˜ ${role}ë‹¤.\n`;
        systemInstructions += `ì£¼ì–´ì§„ ì •ë³´ì™€ ê²€ìƒ‰ ê³„íšì— ë”°ë¼ ì‚¬ìš©ìì˜ ëª©í‘œ ë‹¬ì„±ì„ ë„ì™€ì•¼ í•œë‹¤.\n`;
        systemInstructions += `ëª¨ë“  ë‹µë³€ì€ ë°˜ë“œì‹œ ê²€ìƒ‰ëœ ë‚´ë¶€ ${config.knowledgeSource.ko}ì— ê·¼ê±°í•´ì•¼ í•˜ë©°, ì¶”ì¸¡ì€ ê¸ˆì§€ëœë‹¤.\n`;
        systemInstructions += `ë‹µë³€ì€ í•œêµ­ì–´ë¡œ ì‘ì„±í•œë‹¤.`;
      } else {
        systemInstructions += `You are the best ${role}.\n`;
        systemInstructions += `Following the given information and retrieval plan, your job is to help achieve the user's goal.\n`;
        systemInstructions += `All answers must be based on retrieved internal ${config.knowledgeSource.en}, and speculation is forbidden.\n`;
        systemInstructions += `Provide the answer in English.`;
      }
      // 2. User Request (Goal, Context, Keywords)
      let userRequest = `${tSec.goal}\n${goal || tSec.noGoal}\n\n` +
                        `${tSec.context}\n${context || tSec.noContext}\n\n` +
                        `${tSec.entities}\n${entities || tSec.noEntities}`;
      // 3. Retrieval Plan
      let retrievalPlan = `${tSec.retrievalPlan}\n`;
      retrievalPlan += (lang === 'ko'
                        ? `- ê²€ìƒ‰ ê¸°ê°„: ${timeFrom} ~ ${timeTo}\n`
                        : `- Time range: ${timeFrom} ~ ${timeTo}\n`);
      retrievalPlan += (lang === 'ko'
                        ? `- ê²€ìƒ‰ ëŒ€ìƒ: ${sourcesText}\n`
                        : `- Data sources: ${sourcesText}\n`);
      retrievalPlan += (lang === 'ko'
                        ? `- ê²€ìƒ‰ ë°©ì‹: ${searchModeText}\n`
                        : `- Search mode: ${searchModeText}\n`);
      retrievalPlan += (lang === 'ko' ? `- ìƒì„¸ ì§ˆì˜:\n` : `- Search queries:\n`);
      if (queryLines.length) {
        // Prefix each query with "  - "
        retrievalPlan += queryLines.map(q => "  - " + q).join("\n");
      } else {
        retrievalPlan += "  - " + (lang === 'ko' ? `(${tSec.noQueries})` : `(${tSec.noQueries})`);
      }
      // 4. Output Format Guidelines
      const guideLines = translations[lang].outputGuidelines;
      let outputFormat = `${tSec.outputFormat}\n${(lang === 'ko' 
                        ? "ì•„ë˜ ì§€ì¹¨ì— ë”°ë¼ ìµœì¢… ê²°ê³¼ë¬¼ì„ ìƒì„±í•˜ì„¸ìš”." 
                        : "Follow these guidelines to produce the final answer.")}\n`;
      guideLines.forEach(line => { outputFormat += line + "\n"; });
      if (constraints) {
        outputFormat += (lang === 'ko' ? "- ì¶”ê°€ ìš”êµ¬ì‚¬í•­: " : "- Additional Constraints: ") + constraints;
      } else {
        // If no extra constraints given, for Korean we might use default Markdown suggestion already included in guideLines.
        // For English, already covered general instructions.
      }

      // Combine all parts into final prompt string
      const finalPrompt = `[SYSTEM INSTRUCTIONS]\n${systemInstructions}\n` +
                          `--------------------------------\n` +
                          `[USER REQUEST]\n${userRequest}\n\n${retrievalPlan}\n\n${outputFormat}`;
      document.getElementById('prompt_out').textContent = finalPrompt;
    }

    /** Copies the final prompt to clipboard. */
    function copyAll() {
      const promptText = document.getElementById('prompt_out').textContent;
      try {
        const textarea = document.createElement('textarea');
        textarea.value = promptText;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        showToast(currentLanguage === 'ko' ? 'âœ… í”„ë¡¬í”„íŠ¸ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.' : 'âœ… Prompt copied to clipboard.');
      } catch (err) {
        console.error('Copy failed:', err);
        showToast(currentLanguage === 'ko' ? 'âŒ ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' : 'âŒ Failed to copy. Please check browser settings.');
      }
    }

    /** Clears all input fields and resets to defaults (preserves domain/language selection). */
    function clearAll() {
      const fields = ['role','goal','context','constraints','entities','time_from','time_to','queries','hyde'];
      fields.forEach(id => { 
        const el = document.getElementById(id);
        if (el) el.value = ''; 
      });
      // Reset source checkboxes to domain default
      const defaults = domainConfigs[currentDomain].defaultSources;
      document.getElementById('src_tech_docs').checked = !!defaults.tech_docs;
      document.getElementById('src_test_reports').checked = !!defaults.test_reports;
      document.getElementById('src_email').checked = !!defaults.email;
      // Reset modification flags
      queriesModified = false;
      hydeModified = false;
      // Build prompt with empty fields (will show "(not provided)" placeholders)
      buildPrompt();
      showToast(currentLanguage === 'ko' ? 'ğŸ”„ ì…ë ¥ í•„ë“œë¥¼ ì´ˆê¸°í™”í–ˆìŠµë‹ˆë‹¤.' : 'ğŸ”„ All fields have been cleared.');
    }

    /** Exports the current scenario as a JSON file with all fields. */
    function exportJSON() {
      const data = {
        domain: currentDomain,
        language: currentLanguage,
        model: currentModel,
        role: document.getElementById('role').value,
        goal: document.getElementById('goal').value,
        context: document.getElementById('context').value,
        constraints: document.getElementById('constraints').value,
        entities: document.getElementById('entities').value,
        time_from: document.getElementById('time_from').value,
        time_to: document.getElementById('time_to').value,
        sources: {
          tech_docs: document.getElementById('src_tech_docs').checked,
          test_reports: document.getElementById('src_test_reports').checked,
          email: document.getElementById('src_email').checked
        },
        search_mode: document.getElementById('search_mode').value,
        queries: document.getElementById('queries').value.trim().split(/\n+/).filter(Boolean),
        hyde: document.getElementById('hyde').value,
        prompt: document.getElementById('prompt_out').textContent
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `prompt_${currentDomain}_${currentLanguage}.json`;
      a.click();
    }

    /** Exports the current scenario as a single-line CSV (with header row). */
    function exportCSV() {
      // Define CSV columns and gather values (escaping quotes and newlines appropriately)
      const cols = ["domain","language","model","role","goal","context","constraints","entities",
                    "time_from","time_to","sources_selected","search_mode","queries","hyde","prompt"];
      const data = {
        domain: currentDomain,
        language: currentLanguage,
        model: currentModel,
        role: document.getElementById('role').value,
        goal: document.getElementById('goal').value,
        context: document.getElementById('context').value,
        constraints: document.getElementById('constraints').value,
        entities: document.getElementById('entities').value,
        time_from: document.getElementById('time_from').value,
        time_to: document.getElementById('time_to').value,
        sources_selected: (() => {
          let arr = [];
          if(document.getElementById('src_tech_docs').checked) arr.push("tech_docs");
          if(document.getElementById('src_test_reports').checked) arr.push("test_reports");
          if(document.getElementById('src_email').checked) arr.push("email");
          return arr.join("|");
        })(),
        search_mode: document.getElementById('search_mode').value,
        queries: document.getElementById('queries').value.trim().split(/\n+/).join("|"),
        hyde: document.getElementById('hyde').value,
        prompt: document.getElementById('prompt_out').textContent
      };
      // Escape any double quotes by doubling them, wrap each field in quotes
      let header = cols.join(",") + "\n";
      let row = cols.map(col => {
        let val = data[col] || "";
        // Replace any newline in value with space to keep CSV one-line (except prompt which might be multiline - also flatten it)
        if (typeof val === 'string') {
          val = val.replace(/\r?\n/g, ' '); 
        }
        // Escape quotes
        val = `"${val.replace(/"/g, '""')}"`;
        return val;
      }).join(",");
      const csvContent = header + row;
      const blob = new Blob([csvContent], { type: "text/csv" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `prompt_${currentDomain}_${currentLanguage}.csv`;
      a.click();
    }

    /** Exports the current scenario in an instruction-tuning friendly JSON format. */
    function exportInstructJSON() {
      // Using Alpaca-style format: instruction + input + output
      const goal = document.getElementById('goal').value;
      const context = document.getElementById('context').value;
      const instructionText = goal || "(No goal)"; 
      const inputText = context || "";
      // No ground-truth output available (this is for user to possibly fill in later with an answer)
      const outputText = "";
      const instObj = {
        instruction: instructionText,
        input: inputText,
        output: outputText
      };
      const blob = new Blob([JSON.stringify(instObj, null, 2)], { type: "application/json" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `instruction_${currentDomain}_${currentLanguage}.json`;
      a.click();
    }

    // --- Event Listeners for dynamic behavior ---
    // Track manual edits to queries and hyde
    document.getElementById('queries').addEventListener('input', () => {
      queriesModified = true;
    });
    document.getElementById('hyde').addEventListener('input', () => {
      hydeModified = true;
    });
    // Generate queries when user clicks the button
    document.getElementById('btn_gen_queries').addEventListener('click', () => {
      suggestQueries();
      // After auto-generating, consider it system-generated (user not modified yet)
      queriesModified = false;
      // If user hasn't manually edited HyDE, we can also refresh it to match new queries
      if (!hydeModified) {
        generateHyde();
      }
      buildPrompt();
    });
    // Generate HyDE when button clicked
    document.getElementById('btn_gen_hyde').addEventListener('click', () => {
      generateHyde();
      hydeModified = false; // now it's auto-generated
    });
    // Re-build prompt manually
    document.getElementById('btn_build').addEventListener('click', () => {
      buildPrompt();
    });
    // Copy prompt
    document.getElementById('btn_copy').addEventListener('click', copyAll);
    // Clear all fields
    document.getElementById('btn_clear').addEventListener('click', clearAll);
    // Export buttons
    document.getElementById('btn_export_json').addEventListener('click', exportJSON);
    document.getElementById('btn_export_csv').addEventListener('click', exportCSV);
    document.getElementById('btn_export_instr').addEventListener('click', exportInstructJSON);
    // Domain selection change
    document.getElementById('domain').addEventListener('change', (e) => {
      currentDomain = e.target.value;
      // Reset source checkboxes to new domain defaults
      const defaults = domainConfigs[currentDomain].defaultSources;
      document.getElementById('src_tech_docs').checked = !!defaults.tech_docs;
      document.getElementById('src_test_reports').checked = !!defaults.test_reports;
      document.getElementById('src_email').checked = !!defaults.email;
      // If queries or hyde were manually modified, we discard those modifications on domain change (different context)
      queriesModified = false;
      hydeModified = false;
      // Update UI labels/placeholders for new domain
      updateUI();
      // Regenerate suggestions based on existing inputs (if any) for the new domain
      suggestQueries();
      generateHyde();
      // Rebuild prompt with possibly new domain-specific text
      buildPrompt();
    });
    // Language selection change
    document.getElementById('language').addEventListener('change', (e) => {
      currentLanguage = e.target.value;
      // Update UI text for new language (keep domain and content same)
      updateUI();
      // Rebuild prompt in the new language
      buildPrompt();
    });
    // Model selection change
    document.getElementById('model').addEventListener('change', (e) => {
      currentModel = e.target.value;
      // If needed, one could adjust suggestions based on model here. We'll just regenerate HyDE if not manually edited.
      if (!hydeModified) {
        generateHyde();
      }
      // (No direct prompt text change on model selection, so no buildPrompt call needed apart from HyDE update)
    });
    // Input fields on-the-fly suggestions:
    // When goal/context/entities change, auto-suggest queries/HyDE if user hasn't overridden them manually
    ['goal','context','entities'].forEach(id => {
      document.getElementById(id).addEventListener('input', () => {
        if (!queriesModified) {
          suggestQueries();
        }
        if (!hydeModified) {
          generateHyde();
        }
        buildPrompt();
      });
    });
    // Other inputs (role, constraints, dates, search_mode, source checks) directly trigger prompt rebuild on change
    ['role','constraints','time_from','time_to','search_mode','src_tech_docs','src_test_reports','src_email']
      .forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        const eventName = el.type === 'checkbox' || el.tagName === 'SELECT' ? 'change' : 'input';
        el.addEventListener(eventName, () => {
          buildPrompt();
        });
      });

    // --- Initialization on page load ---
    window.addEventListener('DOMContentLoaded', () => {
      // Set initial selections (Korean & Automotive by default)
      document.getElementById('language').value = currentLanguage;
      document.getElementById('domain').value = currentDomain;
      document.getElementById('model').value = currentModel;
      // Apply UI text for defaults and set default checkboxes
      updateUI();
      // Initialize sources checkboxes default state
      const defaults = domainConfigs[currentDomain].defaultSources;
      document.getElementById('src_tech_docs').checked = !!defaults.tech_docs;
      document.getElementById('src_test_reports').checked = !!defaults.test_reports;
      document.getElementById('src_email').checked = !!defaults.email;
      // Build initial prompt (with placeholders indicating empty inputs)
      buildPrompt();
    });
  </script>
</body>
</html>
